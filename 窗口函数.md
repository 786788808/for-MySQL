##### 背景：
##### 平时想看产品销量排名，但是用一般的函数操作起来，似乎有点麻烦，思路一断就崩盘。寻思，难道没有封装函数之类的，一键操作？  
##### 于是，找到了更方便的窗口函数，终于可以省省脑力了。（涉及分组和排序的时候，用这个）  
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605080956732&di=09faf5f4562ec3b039d84ca015dfa279&imgtype=0&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2137599517%2C366805415%26fm%3D214%26gp%3D0.jpg)  
##### 1.先举个栗子： 
经典问题：  
排名问题：业务需求“在每个组内排名”，比如，每个部门按业绩来排名  
TOPN问题：找出每个部门工资排名前N的员工  
相关业务问题：  
每个类别下用户最喜欢的产品是哪个？  
每个类别下用户点击最多的5个商品是什么？  

```
（1）我手上有5家店铺的交易数据，表名：payment,列：sku(产品sku),quanqity(销售数量)。领导想看每家店铺的销售数量排行，了解近期每家店的销量情况。    
select *, 
rank() over(partition by `店铺` order by `quantity` desc)  as `ranking`   
from `payment`;

说明：
partition by 用于分组，类似于group by; order by用于排序
输出结果是在每行记录后面新增一列：ranking，作为产品销量的排行。并不会像聚合函数一样将数据压缩成一行。在找销量前几的产品时贼好用。  
还有两个排序函数：row_number(),dense_rank()。  
区别在于排序方式不同(是否跳序号）:row_number(1234), dense_rank(1123), rank(1134)  
不懂的，实操一下即可：
select *, 
rank() over(partition by `店铺` order by `quantity` desc)  as `ranking`,      # 不partition就不分组，记得起别名
row_number() over(partition by `店铺` order by `quantity` desc)  as `row_num`,
dense_rank() over(partition by `店铺` order by `quantity` desc)  as `dense_ran`
from `payment`;

（2）难度再加一点，如果领导只想看店铺销量前5的产品，咋整？？？在上面答案的基础上，再加多一个子查询呗   
为啥要加子查询？？直接写where限定不好吗？多次一举？？？  
那是因为如果直接写where ranking<=5,会报错：> 1054 - Unknown column 'ranking' in 'where clause'。（不信自己测试一下）因为ranking在select语句后面才出现（又是语句执行顺序问题）。
常见错误写法：（我第一次就是这么写的，啊哈哈哈哈哈哈哈哈）  
select *, 
rank() over (partition by `店铺` order by `quantity` desc)  AS `ranking`   
from `payment`
where ranking<=5;

这这这这这这才是正确写法：  
select *
from (select *, 
      rank() over (partition by `店铺` order by `quantity` desc)  AS `ranking`   
      from `payment` 
      ) as test   # 注意注意注意，一定要给新表起别名，不然会报错
where ranking<=5;
 ````
##### 2.窗口函数： 
上面是业务经常遇到的问题，正因为这类问题，才引出要讲的窗口函数。  
窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。（听不懂，没关系，会用就好）  
基本语法如下：  
<窗口函数> over (partition by `用于分组的列名` order by `用于排序的列名`)
说明：
 窗口函数可以是专有的窗口函数（row_nember(),dense_rank(),rank()等等），也可以是聚合函数（avg(),sum(),max(),min(),count()等等）  
 是对where或者group by子句处理后的结果进行操作，原则上放在 select 语句里。
 
 在第1点中，举了专有窗口函数的例子。这些专有函数的括号里是空的，都是row_number()、dense_rank()、rank()这样。
 现在讲聚合函数，聚合函数的括号里，必须加列名。如sum(`quantity`)、avg(`quantity`)。
```
SELECT *,
count(`quantity`) over(partition by `店铺`order by `quantity` desc) as `counted`,    #有order by就会看见随着数据行的变化，count\sum\avg这些结果会随行变化。
sum(`quantity`) over(partition by `店铺` order by `quantity` desc) as `sumed`,       #当你想看4月的销售数据时，你可以用order by看到截止到某一天的平均销售额、销售总额
avg(`quantity`) over(partition by `店铺` order by `quantity` desc) as `avged`,       #没有order by，每组的结果都是恒定的
max(`quantity`) over(partition by `店铺` order by `quantity` desc) as `maxed`,
min(`quantity`) over(partition by `店铺` order by `quantity` desc) as `mined`
FROM `payment`
;
 ```               
