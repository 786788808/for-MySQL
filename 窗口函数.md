##### 背景：
##### 平时想看产品销量排名，但是用一般的函数操作起来，似乎有点麻烦，思路一断就崩盘。寻思，难道没有封装函数之类的，一键操作？  
##### 于是，找到了更方便的窗口函数，终于可以省省脑力了。（涉及分组和排序的时候，用这个）  
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605080956732&di=09faf5f4562ec3b039d84ca015dfa279&imgtype=0&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2137599517%2C366805415%26fm%3D214%26gp%3D0.jpg)  
##### 1.先举个栗子：  
######（1）我手上有5家店铺的交易数据，我想看每家店铺的销售数量排行，了解每家店产品销量情况。    
表名：payment,列：sku(产品sku),quanqity(销售数量)   
```select *, 
rank() over(partition by `店铺` order by `quantity` desc)  as `ranking`   
from `payment`;```

说明：
partition by 用于分组，类似于group by; order by用于排序
输出结果是在每行记录后面新增一列：ranking，作为产品销量的排行。并不会像聚合函数一样将数据压缩成一行。在找销量前几的产品时贼好用。  
排序方面，还有row_number(),dense_rank()。  
区别在于排序方式不同：(是否跳序号）  
row_number(1234), dense_rank(1123), rank(1134)  

######（2）对刚刚的例子再进一步，如果我要去店铺销量前5的产品，咋整？加多一个子查询呗   
如果直接写where ranking<=5,会报错：> 1054 - Unknown column 'ranking' in 'where clause'。因为ranking在select语句后面才出现（又是语句执行顺序问题）。
####### 错误写法： 
```select *, 
rank() over (partition by `店铺` order by `quantity` desc)  AS `ranking`   
from `payment`
where ranking<=5;```  

####### 正确写法：  
```select *
from (select *, 
      rank() over (partition by `店铺` order by `quantity` desc)  AS `ranking`   
      from `payment` 
      ) as test   # 注意，一定要给新表起别名，不然会报错
where ranking<=5; ````
