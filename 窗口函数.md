##### 背景：
##### 平时想看产品销量排名，但是用一般的函数操作起来，似乎有点麻烦，思路一断就崩盘。寻思，难道没有封装函数之类的，一键操作？  
##### 于是，找到了更方便的窗口函数，终于可以省省脑力了。（涉及分组和排序的时候，用这个）  
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605080956732&di=09faf5f4562ec3b039d84ca015dfa279&imgtype=0&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2137599517%2C366805415%26fm%3D214%26gp%3D0.jpg)  
##### 1.先举个栗子： 
经典问题：  
排名问题：业务需求“在每个组内排名”，比如，每个部门按业绩来排名  
TOPN问题：找出每个部门工资排名前N的员工  
相关业务问题：  
每个类别下用户最喜欢的产品是哪个？  
每个类别下用户点击最多的5个商品是什么？  
上面是一些相对经典的问题，用窗口函数来解决很合适  

现在，我手上有5家店铺的交易数据，表名：win_payment,列：store，year, sku(产品sku),quanqity(销售数量)，sales（销售额）。这是一个最基本的表，汇总了每年每家店铺每个sku的销售数量，销售额。  
![](https://ftp.bmp.ovh/imgs/2020/11/5b71df283c7c6452.png)  
#### 需求（1）：现在领导想看今年每家店铺产品的销售数量排行，看哪些产品排前，哪些排后，有个大体了解。       
```
select *, dense_rank() over(partition by store order by quantity desc) as ranking 
from `win_payment`
where year=2020;
```
output:   
![](https://ftp.bmp.ovh/imgs/2020/11/bd6207f7e3d4a351.png)  
说明：
partition by 用于分组，类似于group by; order by用于排序
输出结果是在每行记录后面新增一列：ranking，作为产品销量的排行。并不会像聚合函数一样将数据压缩成一行。在找销量前几的产品时贼好用。  
这里我用了其中一个排序函数dense_rank()，还有另外两个排序函数：row_number(),rank()。区别在于排序方式不同(是否跳序号）:row_number(1234), dense_rank(1123), rank(1134)  
>
下面展示三个排序函数，对比他们的用法：  
```
SELECT *,
      dense_rank() over(partition by store order by quantity desc) as rank_dense, 
      row_number() over(partition by store order by quantity desc) as rank_row,
      rank() over(partition by store order by quantity desc) as rank_rank
FROM `win_payment`
where year=2020;  
```
>
output:   
![](https://ftp.bmp.ovh/imgs/2020/11/630f09602b52ea6f.png)  
>
有一种比较简洁的写法，起别名(拓展part)：   
```
SELECT *,
      dense_rank() over ww as rank_dense, 
      row_number() over ww as rank_row,
      rank() over ww as rank_rank
FROM `win_payment`
where year=2020
window ww as (partition by store order by quantity desc);   
```
输出结果和上图是一样的。  
>
>
难度加大一点  
#### 需求（2）：现在领导想看今年每家店铺产品的销售数量排行， 并且只要看前五产品，其他不想看   
常见错误写法：（我第一次就是这么写的，啊哈哈哈哈哈哈哈哈）  
```
select *, 
dense_rank() over (partition by `store` order by `quantity` desc)  AS `ranking`   
from `win_payment`
where ranking<=5;  
```
会报错：> 1054 - Unknown column 'ranking' in 'where clause'  
报错原因：执行语句顺序问题。select里面用到的是输出后的列，而where在输出结果前去过滤，where在from子句后面，只有win_payment表里面的列，但是win_payment是没有ranking列的呀，所以where是无法执行的，所以报错告诉你写错了。  
>
请看正确写法：   
```
select *
from (SELECT *,dense_rank() over(partition by store order by quantity desc) as ranking 
      FROM `win_payment`
      where year=2020) as aa
where ranking <=5;   
```
 output:   
 ![](https://ftp.bmp.ovh/imgs/2020/11/134dca2a192c40e2.png)  
 
##### 2.窗口函数： 
上面是业务经常遇到的问题，正因为这类问题，才引出要讲的窗口函数。  
窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。（听不懂，没关系，会用就好）  
基本语法如下：  
<窗口函数> over (partition by `用于分组的列名` order by `用于排序的列名`)
说明：
 窗口函数可以是专有的窗口函数（row_nember(),dense_rank(),rank()等等），也可以是聚合函数（avg(),sum(),max(),min(),count()等等）  
 是对where或者group by子句处理后的结果进行操作，原则上放在 select 语句里。
 
 在第1点中，举了专有窗口函数的例子。这些专有函数的括号里是空的，都是row_number()、dense_rank()、rank()这样。

SELECT *,
count(`quantity`) over(partition by `店铺`order by `quantity` desc) as `counted`,    #有order by就会看见随着数据行的变化，count\sum\avg这些结果会随行变化。
sum(`quantity`) over(partition by `店铺` order by `quantity` desc) as `sumed`,       #当你想看4月的销售数据时，你可以用order by看到截止到某一天的平均销售额、销售总额
avg(`quantity`) over(partition by `店铺` order by `quantity` desc) as `avged`,       #没有order by，每组的结果都是恒定的
max(`quantity`) over(partition by `店铺` order by `quantity` desc) as `maxed`,
min(`quantity`) over(partition by `店铺` order by `quantity` desc) as `mined`
FROM `payment`
;
              
##### 3.关于order by：
order by+字段就结束的话，默认从统计第一行到最后一行的数据。
进阶一下，类似时间序列里的移动平均概念。拿avg函数来当例子,领导想看近7天的销售数量（假设该表以日记录每个sku的销售情况），并且想看环比情况。于是：

SELECT *,
avg(`quantity`) over(partition by `店铺` order by `quantity` desc) as `avg_quantity`,       #统计窗口开始行到当前行
avg(`quantity`) over(partition by `店铺` order by `quantity` desc rows between 6 preceding and current row) as `7_days_avg_quantity`  #（统计前6+当前天）的平均销量
FROM `payment`
;

基本概念：ROWS BETWEEN 一个时间点 AND 一个时间点
作用：通过preceding,following,current row等调整作用范围，基本语法为

时间点可以表示为：
n preceding: 前n行
n following：后n行
current row ： 当前行
unbounded preceding：窗口第一行
unbounded following：窗口的最后一行

    
 # 未完待续
